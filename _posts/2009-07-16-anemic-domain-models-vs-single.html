<p>
One discussion I keep hearing come up <a title="The Anemic Domain Model Pattern" href="http://codebetter.com/blogs/gregyoung/archive/2009/07/15/the-anemic-domain-model-pattern.aspx">again</a> and <a title="Anti-Pattern: Anemic Domain Model" href="http://blog.decayingcode.com/2009/02/anti-pattern-anemic-domain-model.html">again</a> in the blogosphere, as well as in the pub, is that of the <a href="http://martinfowler.com/bliki/AnemicDomainModel.html" title="AnemicDomainModel on MartinFowler.com">anemic domain model as an anti-pattern</a>.
</p>
<p>
Whilst I can see the benefits of having a "full-fat" domain model, it seems to go against the <a title="Single Responsibility Principle on Wikipedia" href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a> (SRP).  This is wonderfully illustrated by Robert Martin on the <a title="Show 145: SOLID Principles with Uncle Bob - Robert C. Martin" href="http://www.hanselminutes.com/default.aspx?showID=163">Hanselminutes podcast</a>, about 3 minutes in.  In this podcast Martin argues against having an object having multiple reason to change.
</p>
<p class="center top-margins">
<img src="http://www.cogworks.co.uk/images/blog/rich-domain-model.jpg" alt="A rich domain model" />
</p>
<p>
In this example, the employee class knows too much about it's construction and persistence.  This can be <a title="How to avoid Anemic Domain Models and maintain Separation of Concerns?" href="http://stackoverflow.com/questions/227856/how-to-avoid-anemic-domain-models-and-maintain-separation-of-concerns">easily addressed</a> using standard Domain Driven Design (DDD) Factory and Repository patterns:
</p>
<p class="center top-margins">
<img src="http://www.cogworks.co.uk/images/blog/domain-driven-design-domain-model.jpg" alt="A domain driven design inspired domain model" />
</p>
<p>
However, we're still left with the employee object having multiple responsibilities, and multiple reasons to change.  Some argue that this is a <a href="http://vitamic.wordpress.com/2007/01/04/anemic-domain-model-illustrated/" title="Anemic Domain Model Illustrated">good thing</a>, however I think that particular example is more an illustration of the <a title="Liskov Substitution Principle on Wikipedia" href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov Substitution Principle</a>.
</p>
<p>
Following Robert Martin's example to its logical conclusion, we end up with an service-oriented architecture (SoA) approach, and an Anemic Domain Model.
</p>
<p class="center top-margins">
<img src="http://www.cogworks.co.uk/images/blog/anemic-domain-model.jpg" alt="An anemic domain model" />
</p>
<p>
So which approach would I use?  A rich domain model or an anemic one, with an <acronym title="Service-oriented Architecture">SoA</acronym> and <acronym title="Single Responsibility Principle">SRP</acronym>?  In my opinion it is easier to write a loosely coupled, testable, anemic domain with an <acronym title="Service-oriented Architecture">SoA</acronym>, than it is to write a full interactive domain.  By using the <acronym title="Service-oriented Architecture">SoA</acronym> approach, you can essentially defer the question, "when should I split this functionality into another class?" - it is answered for you by the <acronym title="Single Responsibility Principle">SRP</acronym>. 
</p>
<p>
With a greater level of skill required to write a good rich domain model, I tend to go for the anemic option when possible - it is easier to point to the <acronym title="Single Responsibility Principle">SRP</acronym> than it is to count on good OO design acumen.  Of course, this depends on the project your working on and the people your working with.
</p>