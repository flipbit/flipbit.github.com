---
layout: post
title: Writing iPhone Sites with ASP.NET MVC
title_short: Writing iPhone Sites with ASP.NET MVC
pretty_date: Wednesday, 22 July 2009
---
<p>
<strong>Update:</strong> <a href="http://www.hanselman.com/blog/">Scott Hanselman</a> has an elegant solution supporting multiple devices by creating a new <a href="http://www.hanselman.com/blog/MixMobileWebSitesWithASPNETMVCAndTheMobileBrowserDefinitionFile.aspx">mobile view engine</a>.
</p>
<div class="downloader floatRight"><a href="http://www.flipbit.co.uk/downloads/mobile-safari-filter-for-asp-mvc.zip" title="Download the latest version of Mobile Safari Filter for ASP.NET MVC">Download</a>
<span>Released:<br/>
22nd July, 2009</span>
</div>
<p>
Whilst working on a recent project I noticed that I was getting some traffic from Apple iPhones and iPod Touches.  The site used some pretty complex jQuery for user interaction - this didn't translate into a workable user experience for mobile users.
</p>
<p class="center top-margins">
<img title="The iPhone displaying a site with regular HTML"  alt="The iPhone displaying a site with regular HTML" src="http://www.flipbit.co.uk/images/blog/normal-site-on-iphone.jpg" />
</p>
<p>
Writing a Mobile Safari site is made easy with some of ASP.NET MVC's Aspect Orientated Programming (AOP) features.  These allow you to address cross-cutting concerns with the use of filters.  A filter can be attached to a controller or controller action, and run before or after the action is executed.
</p>
<h3>Processing iPhone Requests</h3>
<p>
To get a website to display a Mobile Safari version of the HTML for the iPhone, you can simply write a filter to switch between the standard HTML and the mobile version.  Using the filter is as simple as decorating the controller with the MobileFilter attribute:
</p>
<pre name="code" class="csharp:nocontrols">using System.Web.Mvc;
using Flipbit.Web.Filters;

namespace Flipbit.Web.Controllers
{
  [MobileFilter]
  public class HomeController : Controller
  {
    /// &lt;summary&gt;
    /// Shows the homepage.
    /// &lt;/summary&gt;
    public ViewResult Index()
    {
      return View();
    }
  }
}</pre>
<p>
The MobileFilter executes after the action has executed, and simply decides whether to show the mobile version of the site or not.
</p>
<pre name="code" class="csharp:nocontrols">/// &lt;summary&gt;
/// Called when the controller action is executed.
/// &lt;/summary&gt;
public override void OnActionExecuted(ActionExecutedContext filterContext)
{
  // Only process when request is from mobile Safari
  if (!IsMobileSafari(filterContext.RequestContext.HttpContext)) return;

  // Only process Views
  if (filterContext.Result.GetType() != typeof (ViewResult)) return;

  // Get the name of the view
  var viewName = GetViewName(filterContext);

  var mobileViewName = viewName + ".iPhone";

  // Ensure that a mobile view has been defined
  if (!ViewExists(mobileViewName, filterContext)) return;

  // Assign the new mobile view
  var result = (ViewResult)filterContext.Result;
  result.ViewName = mobileViewName;
}</pre>
<h3>Detecting a Request from an iPhone or iPod</h3>
<p>
The first thing the filter needs to do is determine if the user is accessing the site through an iPhone or iPod touch.  We can do this by examining the UserAgent string in the incoming HTTP request.  If the device is an iPhone, the UserAgent will look like this:
</p>
<p class="code">
Mozilla/5.0 (iPhone; U; CPU like Mac OS X; en) AppleWebKit/420+ (KHTML, like Gecko) Version/3.0 Mobile/1C28 Safari/419.3
</p>
<p>
Meanwhile, the iPod touch looks like this:
</p>
<p class="code">
Mozilla/5.0 (iPod; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3A100a Safari/419.3
</p>
<p>
In order to detect this, you can simply examine the UserAgent for an instance of the text "iPod" or "iPhone".  This should provide some protection for changes to the UserAgent over time due to upgrades etc...
</p>
<pre name="code" class="csharp:nocontrols">/// &lt;summary&gt;
/// Determines whether this request was made from a mobile safari device
/// &lt;/summary&gt;
/// &lt;param name="context"&gt;The context.&lt;/param&gt;
/// &lt;returns&gt;
/// &lt;c&gt;true&lt;/c&gt; if request is from mobile safari; otherwise, &lt;c&gt;false&lt;/c&gt;.
/// &lt;/returns&gt;
public bool IsMobileSafari(HttpContextBase context)
{
  var isMobileSafari = false;

  if (context != null)
  {
    var userAgent = context.Request.UserAgent;

    if (!string.IsNullOrEmpty(userAgent))
    {
      var ipodIndex = userAgent.IndexOf("iPod");
      var iphoneIndex = userAgent.IndexOf("iPhone");

      if (iphoneIndex + ipodIndex > -1) isMobileSafari = true;
    }
  }

  return isMobileSafari;
}
</pre>
<h3>Dynamically Switching the View</h3>
<p>
If the request is from an iPhone or iPod touch, we need to use the HTML for Mobile Safari.  This is stored along side the regular view, however has ".iPhone" appended to the view file name.  This allows us to maintain two separate versions of the HTML and keep the same controller logic.
</p>
<pre name="code" class="csharp:nocontrols">/// &lt;summary&gt;
/// Views the exists.
/// &lt;/summary&gt;
/// &lt;param name="viewName"&gt;Name of the view.&lt;/param&gt;
/// &lt;param name="filterContext"&gt;The filter context.&lt;/param&gt;
private bool ViewExists(string viewName, ActionExecutedContext filterContext)
{
  // get the controller name
  var controller = filterContext.ActionDescriptor.ControllerDescriptor.ControllerName;

  // get the path to the view & map to IIS location
  var path = string.Format("~/Views/{0}/{1}.aspx", controller, viewName);
  path = filterContext.RequestContext.HttpContext.Server.MapPath(path);

  // see if the view exists
  return File.Exists(path);
}
</pre>
<p>
The filter checks to see if the mobile view exists.  If it does not, then the normal view is used by default, allowing the site to gracefully degrade if the mobile view is missing for some reason.
</p>
<p class="center top-margin screens">
<img title="Mobile views along side regular ones in Visual Studio" alt="Mobile views along side regular ones in Visual Studio" src="http://www.flipbit.co.uk/images/blog/mobile-mvc-views.jpg" />
</p>
<h3>Writing and Testing Mobile Safari HTML</h3>
<p>
With the filter in place it's time to start writing some HTML for Mobile Safari.  There are numerous sites to <a title="iPhone Web Page Template" href="http://www.modmyi.com/forums/web-apps/637-iphone-web-page-template.html">help get you started</a> and <a title="Windows iPhone Emulator" href="http://labs.blackbaud.com/NetCommunity/article?artid=662">test</a> the <a title="Online iPhone tester" href="http://iphonetester.com/">result</a> without having to do a full deploy and test using the iPhone.
</p>
<p class="center top-margin">
<img title="The iPhone displaying a site with Mobile Safari HTML" alt="The iPhone displaying a site with Mobile Safari HTML" src="http://www.flipbit.co.uk/images/blog/mobile-safari-site-on-iphone.jpg" />
</p>
<p>
Once you've finished, you should have a dynamically switching, mobile compatible version of your site.  A sample of this code is <a href="http://www.flipbit.co.uk/downloads/mobile-safari-filter-for-asp-mvc.zip" title="Download the latest version of Mobile Safari Filter for ASP.NET MVC">available to download</a>.
</p>